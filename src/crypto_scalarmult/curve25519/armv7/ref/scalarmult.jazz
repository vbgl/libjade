inline
fn addto(reg ptr u32[32] a b) -> reg ptr u32[32] {
  inline int j;
  reg u32 u t;
  u = 0;
  for j = 0 to 31 {
    t = b[j];
    u += t;
    t = a[j];
    u += t;
    t = u & 0xff;
    a[j] = t;
    u >>= 8;
  }
  t = b[31];
  u += t;
  t = a[31];
  u += t;
  a[31] = u;
  return a;
}

fn add(reg ptr u32[32] out a b) -> reg ptr u32[32] {
  inline int j;
  reg u32 u t;
  u = 0;
  for j = 0 to 31 {
    t = b[j];
    u += t;
    t = a[j];
    u += t;
    t = u & 0xff;
    out[j] = t;
    u >>= 8;
  }
  t = b[31];
  u += t;
  t = a[31];
  u += t;
  out[31] = u;
  return out;
}

fn sub(reg ptr u32[32] out a b) -> reg ptr u32[32] {
  inline int j;
  reg u32 u v w;
  u = 218;
  for j = 0 to 31 {
    v = a[j];
    v += 65280;
    w = b[j];
    v -= w;
    u += v;
    v = u & 0xff;
    out[j] = v;
    u >>= 8;
  }
  v = a[31];
  w = b[31];
  v -= w;
  u += v;
  out[31] = u;
  return out;
}

inline
fn squeeze_aux(reg ptr u32[32] a, reg u32 u) -> reg ptr u32[32], reg u32 {
  inline int j;
  reg u32 t;
  for j = 0 to 31 {
    t = a[j];
    u += t;
    t = u & 0xff;
    a[j] = t;
    u >>= 8;
  }
  return a, u;
}

inline
fn mul19(reg u32 u) -> reg u32 {
  reg u32 t;
  t = u + (u << 3);
  u += t << 1;
  return u;
}

fn squeeze(reg ptr u32[32] a) -> reg ptr u32[32] {
  reg u32 u t;
  u = 0;
  a, u = squeeze_aux(a, u);
  t = a[31];
  u += t;
  t = u & 127;
  a[31] = t;
  u >>= 7;
  u = mul19(u);
  a, u = squeeze_aux(a, u);
  t = a[31];
  u += t;
  a[31] = u;
  return a;
}

u32[32] minusp = {
 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128
};

fn freeze(reg ptr u32[32] a) -> reg ptr u32[32] {
  stack u32[32] aorig;
  inline int j;
  reg u32 n t k;
  for j = 0 to 32 {
    t = a[j];
    aorig[j] = t;
  }
  a = addto(a, minusp);
  t = a[31];
  t >>= 7;
  t &= 1;
  n = -t;
  for j = 0 to 32 {
    t = aorig[j];
    k = a[j];
    t ^= k;
    t &= n;
    k ^= t;
    a[j] = k;
  }
  return a;
}

// acc += 38 * x
inline
fn mul38_acc(reg u32 acc x) -> reg u32 {
  x = mul19(x);
  acc += x << 1;
  return acc;
}

fn mult(reg ptr u32[32] out a b) -> reg ptr u32[32] {
  inline int i j;
  for i = 0 to 32 {
    reg u32 u;
    u = 0;
    for j = 0 to i + 1 {
      reg u32 x y;
      x = a[j];
      y = b[i - j];
      u += x * y;
    }
    for j = i + 1 to 32 {
      reg u32 x y;
      x = a[j];
      y = b[i + 32 - j];
      x *= y;
      u = mul38_acc(u, x);
    }
    out[i] = u;
  }
  out = squeeze(out);
  return out;
}

fn mult121665(reg ptr u32[32] out a) -> reg ptr u32[32] {
  inline int j;
  reg u32 u t k;
  u = 0;
  for j = 0 to 31 {
    t = a[j];
    k = 0xdb41;
    k = #MOVT(k, 1);
    u += k * t;
    t = u & 0xff;
    out[j] = t;
    u >>= 8;
  }
  t = a[31];
  k = 0xdb41;
  k = #MOVT(k, 1);
  u += k * t;
  t = u & 127;
  out[31] = t;
  u >>= 7;
  u = mul19(u);
  out, u = squeeze_aux(out, u);
  t = out[31];
  u += t;
  out[31] = u;
  return out;
}

fn square(reg ptr u32[32] out a) -> reg ptr u32[32] {
  inline int i j;
  reg u32 u;
  for i = 0 to 32 {
    u = 0;
    for j = 0 to (i + 1) / 2 {
      reg u32 x y;
      x = a[j];
      y = a[i - j];
      u += x * y;
    }
    for j = i + 1 to (i + 33) / 2 {
      reg u32 x y;
      x = a[j];
      y = a[i + 32 - j];
      x *= y;
      u = mul38_acc(u, x);
    }
    u <<= 1;
    if (i & 1) == 0 {
      reg u32 x;
      x = a[i / 2];
      u += x * x;
      x = a[i / 2 + 16];
      x *= x;
      u = mul38_acc(u, x);
    }
    out[i] = u;
  }
  out = squeeze(out);
  return out;
}

/* cond != 0
    p ← s
    q ← r
*/
fn select(reg ptr u32[64] p q r s, reg u32 cond) -> reg ptr u32[64], reg ptr u32[64] {
  inline int j;
  reg bool f;
  f = cond != 0;
  for j = 0 to 64 {
    reg u32 a b c;
    a = r[j];
    b = s[j];
    c = a;
    a = b if f;
    b = c if f;
    p[j] = a;
    q[j] = b;
  }
  return p, q;
}

fn mainloop(reg ptr u32[64] work, reg ptr u8[32] e) -> reg ptr u32[64] {
  stack u32[64] xzm1 xzm xzmb xzm1b xznb xzn1b;
  stack u32[64] a0 a1 b0 b1 c1;
  stack u32[32] r s t u;
  inline int j;
  reg u32 pos tmp;
  for j = 0 to 32 {
    tmp = work[j];
    xzm1[j] = tmp;
  }
  tmp = 1;
  xzm1[32] = tmp;
  for j = 33 to 64 {
    tmp = 0;
    xzm1[j] = tmp;
  }

  tmp = 1;
  xzm[0] = tmp;
  tmp = 0;
  for j = 1 to 64 {
    xzm[j] = tmp;
  }
 
  pos = 254;
  while (pos >=s 0) {
    reg u32 cond;
    tmp = pos >> 3;
    cond = (32u)e[(int) tmp];
    tmp = pos & 7;
    cond >>= tmp;
    cond &= 1;
    xzmb, xzm1b = select(xzmb, xzm1b, xzm, xzm1, cond);
    a0[0:32] = add(a0[0:32], xzmb[0:32], xzmb[32:32]);
    a0[32:32] = sub(a0[32:32], xzmb[0:32], xzmb[32:32]);
    a1[0:32] = add(a1[0:32], xzm1b[0:32], xzm1b[32:32]);
    a1[32:32] = sub(a1[32:32], xzm1b[0:32], xzm1b[32:32]);
    b0[0:32] = square(b0[0:32], a0[0:32]);
    b0[32:32] = square(b0[32:32], a0[32:32]);
    b1[0:32] = mult(b1[0:32], a1[0:32], a0[32:32]);
    b1[32:32] = mult(b1[32:32], a1[32:32], a0[0:32]);
    c1[0:32] = add(c1[0:32], b1[0:32], b1[32:32]);
    c1[32:32] = sub(c1[32:32], b1[0:32], b1[32:32]);
    r = square(r, c1[32:32]);
    s = sub(s, b0[0:32], b0[32:32]);
    t = mult121665(t, s);
    u = add(u, t, b0[0:32]);
    xznb[0:32] = mult(xznb[0:32], b0[0:32], b0[32:32]);
    xznb[32:32] = mult(xznb[32:32], s, u);
    xzn1b[0:32] = square(xzn1b[0:32], c1[0:32]);
    xzn1b[32:32] = mult(xzn1b[32:32], r, work[0:32]);
    xzm, xzm1 = select(xzm, xzm1, xznb, xzn1b, cond);
    pos -= 1;
  }
  for j = 0 to 64 {
    tmp = xzm[j];
    work[j] = tmp;
  }
  return work;
}

fn recip(reg ptr u32[32] z) -> reg ptr u32[32] {
  stack u32[32] z2 z9 z11 z2_5_0 z2_10_0 z2_20_0 z2_50_0 z2_100_0 t0 t1;
  inline int i;
  z2 = square(z2, z[0:32]);
  t1 = square(t1, z2);
  t0 = square(t0, t1);
  z9 = mult(z9, t0, z[0:32]);
  z11 = mult(z11, z9, z2);
  t0 = square(t0, z11);
  z2_5_0 = mult(z2_5_0, t0, z9);

  t0 = square(t0, z2_5_0);
  t1 = square(t1, t0);
  t0 = square(t0, t1);
  t1 = square(t1, t0);
  t0 = square(t0, t1);
  z2_10_0 = mult(z2_10_0, t0, z2_5_0);

  t0 = square(t0, z2_10_0);
  t1 = square(t1, t0);
  for i = 0 to 4 {
    t0 = square(t0, t1);
    t1 = square(t1, t0);
  }
  z2_20_0 = mult(z2_20_0, t1, z2_10_0);

  t0 = square(t0, z2_20_0);
  t1 = square(t1, t0);
  for i = 0 to 9 {
    t0 = square(t0, t1);
    t1 = square(t1, t0);
  }
  t0 = mult(t0, t1, z2_20_0);

  t1 = square(t1, t0);
  t0 = square(t0, t1);
  for i = 0 to 4 {
    t1 = square(t1, t0);
    t0 = square(t0, t1);
  }
  z2_50_0 = mult(z2_50_0, t0, z2_10_0);

  t0 = square(t0, z2_50_0);
  t1 = square(t1, t0);
  for i = 0 to 24 {
    t0 = square(t0, t1);
    t1 = square(t1, t0);
  }
  z2_100_0 = mult(z2_100_0, t1, z2_50_0);

  t1 = square(t1, z2_100_0);
  t0 = square(t0, t1);
  for i = 0 to 49 {
    t1 = square(t1, t0);
    t0 = square(t0, t1);
  }
  t1 = mult(t1, t0, z2_100_0);

  t0 = square(t0, t1);
  t1 = square(t1, t0);
  for i = 0 to 24 {
    t0 = square(t0, t1);
    t1 = square(t1, t0);
  }
  t0 = mult(t0, t1, z2_50_0);

  t1 = square(t1, t0);
  t0 = square(t0, t1);
  t1 = square(t1, t0);
  t0 = square(t0, t1);
  t1 = square(t1, t0);
  z[0:32] = mult(z[0:32], t1, z11);
  return z;
}

inline
fn scalarmult_ref_body(stack u32[96] work, stack u8[32] e) ->  stack u32[96] {
  work[0:64] = mainloop(work[0:64], e);
  work[32:32] = recip(work[32:32]);
  work[64:32] = mult(work[64:32], work[0:32], work[32:32]);
  work[64:32] = freeze(work[64:32]);
  return work;
}

// q: mut ptr u8[32]
// n: const ptr u8[32]
// p: const ptr u8[32]
export
fn scalarmult_ref(reg u32 q n p) -> reg u32 {
  stack u8[32] e;
  stack u32[96] work;
  inline int i;
  for i = 0 to 32 {
    reg u32 tmp;
    tmp = (32u)(u8)[n + i];
    if i == 0 { tmp &= 248; }
    if i == 31 {
      tmp &= 127;
      tmp |= 64;
    }
    e[i] = tmp;
  }
  for i = 0 to 32 {
    reg u32 tmp;
    tmp = (32u)(u8)[p + i];
    work[i] = tmp;
  }
  work = scalarmult_ref_body(work, e);
  for i = 0 to 32 {
    reg u32 tmp;
    tmp = work[64 + i];
    (u8)[q + i] = tmp;
  }
  reg u32 r;
  r = 0;
  return r;
}
